package org.elkoserver.foundation.net;

import java.util.Iterator;
import org.elkoserver.util.trace.Trace;

/**
 * An HTTPFramer is responsible for extracting messages from HTTP POSTs
 * arriving on an HTTP connection and doing something meaningful with them.  It
 * is also responsible for actually producing the HTTP replies that will be
 * transmitted in response to HTTP requests sent to the server.
 *
 * <p>The base HTTPFramer treats the content of each HTTP POST (to the /xmit/
 * URL) as a simple string being delivered to the server.
 */
public class HTTPFramer {
    private Trace myMsgTrace;

    /**
     * Constructor.
     *
     * @param msgTrace  Trace object for logging message traffic.
     */
    public HTTPFramer(Trace msgTrace) {
        myMsgTrace = msgTrace;
    }

    /**
     * Produce the HTTP reply body for responding to an unrecognized URL (that
     * is, a 404 error).
     *
     * @param badURL  The URL that was no good.
     *
     * @return an appropriate HTTP reply body string to accompany the 404
     *    error that will be returned.
     */
    public String makeBadURLReply(String badURL) {
        /* Error haiku, see http://www.c4vct.com/kym/humor/haikus.htm */
        return
            "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n" +
            "<html><head>\n" +
            "<title>404 Not Found</title>\n" +
            "</head><body>\n" +
            "<h1>Not Found</h1>\n" +
            "The requested URL " + badURL + " was not found here.\n<p>" +
            "<hr><p>The web site you seek<br>\n" +
            "cannot be located but<br>\n" +
            "endless others exist<p>\n" +
            "</body></html>\n\n";
    }

    /**
     * Produce the HTTP reply body containing the JSON string for responding to
     * an HTTP GET or POST of the /connect/ URL.
     *
     * @param sessionID  The session ID number for the session.
     *
     * @return an appropriate HTTP reply body JSON string for responding to a
     *    /connect/ request that created the given session.
     */
    public String makeConnectReply(long sessionID) {
        return
            "{ \"sessionid\": \"" + sessionID + "\" }\n";
    }

    /**
     * Produce the HTTP reply body containing the JSON string for responding to
     * an HTTP GET or POST of the /disconnect/ URL.
     *
     * @return an appropriate HTTP reply body string for responding to a
     *    /disconnect/ request.
     */
    public String makeDisconnectReply() {
        return "{ }\n";
    }

    /**
     * Produce a fragment of the HTTP reply body containing JSON messages in
     * response to an HTTP GET or POST of the /select/ URL.  This JSON text
     * will either deliver a message (or messages) to the client or inform the
     * client that there are no messages at this time.
     *
     * <p>This method is able to produce fragmentary output to support packing
     * multiple messages into a single reply body: the reply consists of a
     * prefix, the actual encoding of the message(s) being sent, and then a
     * suffix.  The prefix is only produced if the 'start' parameter is true;
     * likewise for the suffix and the 'end' parameter.  It is possible to
     * concatenate the fragments generated by any number of calls to this
     * method to produce a valid reply body, so long as the 'start' parameter
     * is set on the first call (and not the others), and the 'end' parameter
     * is set on the last call (and not the others).
     *
     * @param message  The message to be sent, or null if no messages are to be
     *    sent.
     * @param seqNumber  The sequence number for the next select request.
     * @param start  true if this message is the first in a batch.
     * @param end  true if this message is the last in a batch.
     *
     * @return an appropriate HTTP reply body JSON fragment string for
     *    responding to a /select/ by delivering 'message' to the client.
     */
    public String makeSelectReplySegment(Object message, int seqNumber,
                                         boolean start, boolean end)
    {
        String result = "";
        if (start) {
            result += "{ \"msgs\": [";
        } else {
            result += ", ";
        }
        if (message != null) {
            result += "" + message;
        }
        if (end) {
            result += "], \"seqnum\": \"" + seqNumber + "\" }\n";
        }
        return result;
    }

    /**
     * Produce the HTTP reply body containing the JSON string for responding to
     * an HTTP GET or POST where the URL that was presented to the server had
     * an out-of-sequence sequence number or a bad session ID number.
     *
     * @param error  Error string to transmit.
     *
     * @return an appropriate HTTP reply body JSON string for responding to a
     *    URL with a bad sequence number.
     */
    public String makeSequenceErrorReply(String error) {
        return "{ \"error\": \"" + error + "\" }\n";
    }

    /**
     * Produce the HTTP reply body containing the JSON string for responding to
     * an HTTP GET or POST of the /xmit/ URL used to transmit messages from the
     * client to the server.
     *
     * @param seqNumber  The sequence number for the next xmit request.
     *
     * @return an appropriate HTTP reply body JSON string for responding to a
     *    POST or GET delivering messages to the server.
     */
    public String makeXmitReply(int seqNumber) {
        return "{ \"seqnum\": \"" + seqNumber + "\" }\n";
    }

    /**
     * Get the message trace object for this framer.  This trace object should
     * only be used for logging the content of message traffic.  Other server
     * events should be logged to Trace.comm.
     *
     * @return this framer's message trace object.
     */
    Trace msgTrace() {
        return myMsgTrace;
    }

    /**
     * Return an iterator that will return the application-level message or
     * messages (if any) in the body of a received HTTP POST.
     *
     * @param postBody  The HTTP POST body in question.
     *
     * @return an iterator that can be called upon to return the application-
     *    level message(s) contained within 'postBody'.
     */
    public Iterator postBodyUnpacker(String postBody) {
        return new StringBodyUnpacker(postBody);
    }

    /**
     * Post body unpacker for a plain string HTTP message.  In this case, the
     * HTTP POST body contains exactly one message, which is the value of
     * exactly one POSTed form field (whose name doesn't matter).
     */
    private class StringBodyUnpacker implements Iterator {
        /** The message string that was received. */
        private String myReceivedMessage;
        
        /**
         * Constructor.  Just strip the form variable name and remember the
         * rest.
         *
         * @param postBody  The HTTP message body was POSTed.
         */
        public StringBodyUnpacker(String postBody) {
            int junkMark = postBody.indexOf('=');
            if (junkMark >= 0) {
                postBody = postBody.substring(junkMark + 1);
            }
            myReceivedMessage = postBody;
        }
        
        /**
         * Test if there are more messages.
         *
         * <p>When using this unpacking scheme, there can be only one
         * application- level message in an HTTP message.  That message has
         * either been given out or it hasn't.
         */
        public boolean hasNext() {
            return myReceivedMessage != null;
        }
        
        /**
         * Get the next message.
         *
         * <p>Since there is only the one application-level message possible
         * here, just return that, or null if it was returned previously.
         */
        public Object next() {
            Object result = myReceivedMessage;
            myReceivedMessage = null;
            return result;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }
    }
}


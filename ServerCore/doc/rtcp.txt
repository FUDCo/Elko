Resumable TCP

Every generation seems doomed to reimplement TCP, usually over UDP but in our
case we are doing it over TCP on account of shortcomings in the iOS TCP/IP
protocol stack implementation.

This is a protocol for a resumable session abstraction, a message channel based
on TCP (rather, on the way we currently use TCP), but which can span successive
TCP connections in the face of connection interruption.

There are two parties: origin (O) and terminus (T)

Their roles are mostly symmetric except:
  (1) O initiates the session, T accepts the session
  (2) T provides the session ID
  (3) only O can resume the session if the TCP connection is broken

Each party gives each message it sends a unique, monotonically increasing
message sequence number.

Each party generates the sequence numbers for the messages it sends and
observes the sequence numbers generated by its counterparty for messages
flowing in the opposite direction.

The first message each party sends always has sequence number 1.  Each
successive message sent by a party increments their own sequence number by 1.

Each party tracks the sequence numbers of messages received, so that if the TCP
connection is broken, it knows the sequence number of the last message it
received successfully.


Session initiation:

O initiates a session by opening a TCP connection to T and sending:

direction   format
---------   ------
O-->T       "start\n"

O may immediately begin sending messages to T following this, according to the
rules described below.

T responds to O with:

O<--T       "start " <sessionID> "\n"

where:
<sessionID> is an alphanumeric session ID generated by T for the new session.

The intent is that session IDs should be unguessable, i.e., produced from a
cryptographically strong random source and chosen from a very large space of
possible values.

O may only send a "start" request as the first request at the opening of a TCP
connection.  At any other time T will reply with a "sessionInProgress" error.


Message traffic:

A message from O to T takes the form:

O-->T       <seqNumO> " " <seqNumT> "\n" <msg> "\n\n"

where:
<seqNumO> increments by 1 for each message O sends, starting from 1.

<seqNumT> is the <seqNumT> from the last message successfully received by O
from T in this session.  If O has never received any messages from T, <seqNumT>
is 0.

<msg> is the JSON message being sent, framed the same way it is on a raw TCP
connection (i.e., terminated by two successive newlines).

A message from T to O takes the form:

O<--T       <seqNumT> " " <seqNumO> "\n" <msg> "\n\n"

where:
<seqNumT> increments by 1 for each message T sends, starting from 1.

<seqNumO> is the <seqNumO> from the last message successfully received by T
from O in this session.  If T has never received any messages from O, <seqNumO>
is 0.

<msg> is the JSON message being sent, framed the same way it is on a raw TCP
connection.

If a TCP connection is broken in the midst of transmitting a message, the
portions that made it to the receiving end are discarded by the receiver and
the message is considered not to have been received, even if the sequence
number had been successfully read.  O may, at its option, then attempt to
resume the session.

A message may only be transmitted if the session has previously been
established on the TCP connection via a "start" or "resume" request from O to
T.  At any other time, the counterparty will reply with a "noSession" error.

If the sequence number associated with a message is not 1 greater than the
sequence number of the previous message from the same sender, the counterparty
will reply with a "sequenceError" error.


Session keep-alive:

If too much time passes without T receiving anything from O, T may conclude
that O has been disconnected even though the TCP connection is still open
according to T's operating system TCP/IP implementation.

In the absence of having other message traffic to transmit, O may, at its
option, simply signal that it is still there by sending:

O-->T      "ack " <seqNumT> "\n"

where:

<seqNumT> is the <seqNumT> from the last message successfully received by O
from T in this session.  If O has never received any messages from T, <seqNumT>
is 0.

The frequency with which "ack" requests must be sent lest T lose interest in
the connection is outside the scope of this protocol specification.  The
timeout value must instead be mutually understood by O and T as the result of
common design or negotiation.


Session resumption:

If the TCP connection is broken and the session thus interrupted, O may resume
the session by opening a new TCP connection to T and sending:

O-->T       "resume " <sessionID> " " <seqNumT> "\n"

where:
<sessionID> is the session ID (originally provided by T) of the session that
was interrupted.

<seqNumT> is the <seqNumT> of the last message successfully received by O from
T.

T responds with:

O<--T       "resume " <sessionID> " " <seqNumO> "\n"

where:
<sessionID> echoes the session ID from the "resume" request

<seqNumO> is the <seqNumO> of the last message successfully received by T from
O.

O must then resend, in order, all messages it had previously sent whose
<seqNumO> values are greater than the value provided in T's "resume" response,
plus all messages to T that have been accumulated in O's buffers during the TCP
connection outage.  T will also follow its "resume" response with its own
retransmissions, in order, of all messages it had previously sent whose
<seqNumT> values are greater than the value provided in the "resume" request,
plus all messages to O that have been accumulated in T's buffers during the TCP
connection outage.

If the session ID given matches an existing session that T already has
associated with a different, open TCP connection, T will immediately disconnect
that previous TCP connection and resume the session on the newer TCP connection
over which the "resume" request was received, as if the previous TCP connection
had been spontaneously disconnected immediately prior to receipt of the
"resume" request.  This is because network and implementation asymmetries mean
that it is possible in some circumstances for O to detect loss of a TCP
connection, reconnect to T, and attempt to resume, all before T ever becomes
aware of the connection drop at its end.

T may also choose to kill a session while disconnected, for whatever reasons it
likes, notably if too much time passes between the TCP disconnection and the
attempted resumption, or if too many messages from T to O accumulate during the
disconnected interval for T to economically retain them all.

In this case, T responds to the "resume" request with a "noSuchSession" error.
T will also respond with a "noSuchSession" error if the session ID given simply
does not match any session that T currently knows about.

O may only send a "resume" request as the first request at the opening of a TCP
connection.  At any other time T will reply with a "sessionInProgress" error.


Ending a session:

Either party may voluntarily end the session at any time.  A session may be
ended politely or impolitely.

O may end politely by sending:

O-->T       "end " <seqNumT> "\n"

where:
<seqNumT> is the <seqNumT> from the last message successfully received by O
from T in this session.  If O has never received any messages from T, <seqNumT>
is 0.

In the same vein, T may end politely by sending:

O<--T       "end " <seqNumO> "\n"

where:
<seqNumO> is the <seqNumO> from the last message successfully received by T
from O in this session.  If T has never received any messages from O, <seqNumO>
is 0.

After a polite ending by either party, the session is considered dead.

O may end impolitely by simply dropping the TCP connection.  T will eventually
kill its side of the session due to time out or full message buffers.

T may end impolitely by simply dropping the TCP connection, and then responding
with an "error" response if O attempts to "resume".

After an impolite ending, the session may be immediately considered dead by the
ender and will eventually be determined to be dead by the ender's counterparty.


Errors:

At various points in the protocol, one party could send a request that is
inappropriate or erroneous in some way.  The counterparty will respond with:

O<--T       "error " <errorTag> " " <explanatoryText> "\n"

or

T-->O       "error " <errorTag> " " <explanatoryText> "\n"

where:
<errorTag> is an alphanumeric tag string identifying the type of error.  The
set of possible error tag strings is fixed by this protocol definition.

<explanatoryText> is an explanatory, human readable error message.  It
may contain any characters other than newline.  The explanatory text is
optional and may be omitted depending on the whim of the sender.

The possible errors are:

sessionInProgress  When O sends a "start" or "resume" request as something
other than the first transmission after the opening of a new TCP connection.

noSession When either party sends a message to the other but no session has yet
been established by means of a "start" or "resume" request from O to T.

noSuchSession  When O sends a "resume" request to T but T has no active session
with the given session ID.  This may be because T has killed the session due to
timeout or buffer capacity limits, or because there never was any such session.

sequenceError  When either party sends a message whose sequence number is out
of order, by failing to be exactly 1 greater than the sequence number of the
message previously received by the receiving party from the sending party.

unknownRequest  When either party sends a request that is not one of the
request types described by this protocol, i.e., if it is not "start", "resume",
"end", "error", or a message transmission.

After any error response, the session is considered dead and may not be
resumed.  Once a session is dead, each party may discard any messages that it
had retained for later retransmission.
